use crate::{
    purl::service::PurlService, sbom::service::SbomService,
    vulnerability::service::VulnerabilityService,
};
use std::str::FromStr;
use test_context::test_context;
use test_log::test;
use trustify_common::id::Id;
use trustify_common::{
    db::query::{Query, q},
    model::Paginated,
    purl::Purl,
};
use trustify_cvss::cvss3::severity::Severity;
use trustify_entity::remediation::RemediationCategory;
use trustify_test_context::TrustifyContext;

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn all_vulnerabilities(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2021-0079.json", "cve/CVE-2021-32714.json"])
        .await?;

    let vulns = service
        .fetch_vulnerabilities(
            Query::default(),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;

    assert_eq!(1, vulns.items.len());

    assert!(
        vulns.items[0]
            .head
            .description
            .as_ref()
            .unwrap()
            .starts_with("hyper is an HTTP library for Rust")
    );

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn statuses(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2021-0079.json", "cve/CVE-2021-32714.json"])
        .await?;

    let vuln = service
        .fetch_vulnerability("CVE-2021-32714", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    assert_eq!(2, vuln.advisories.len());

    log::debug!("{vuln:#?}");

    let rustsec_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "RUSTSEC-2021-0079");
    assert!(rustsec_advisory.is_some());
    let rustsec_advisory = rustsec_advisory.unwrap();

    let cve_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "CVE-2021-32714");
    assert!(cve_advisory.is_some());
    let cve_advisory = cve_advisory.unwrap();

    let rustsec_statuses: Vec<_> = rustsec_advisory.purls.keys().collect();

    assert_eq!(2, rustsec_statuses.len());
    assert!(rustsec_statuses.contains(&&"fixed".to_string()));
    assert!(rustsec_statuses.contains(&&"affected".to_string()));

    let cve_statuses: Vec<_> = cve_advisory.purls.keys().collect();
    assert_eq!(0, cve_statuses.len());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn statuses_too(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "cve/CVE-2024-29025.json",
        "csaf/rhsa-2024-2705.json",
        "spdx/quarkus-bom-3.2.11.Final-redhat-00001.json",
        "spdx/quarkus-bom-3.2.12.Final-redhat-00002.json",
    ])
    .await?;

    let vuln = service
        .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    log::debug!("{vuln:#?}");

    assert_eq!(2, vuln.advisories.len());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn commons_compress(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let vuln_service = VulnerabilityService::new();
    let sbom_service = SbomService::new(ctx.db.clone());

    // Ingest a CVE declaring the vulnerability present in versions
    // [1.21,1.26.0) of commons-compress, along with 2 sboms, each of
    // which includes a vulnerable version of commons-compress
    let ingest_results = ctx
        .ingest_documents([
            "cve/CVE-2024-26308.json",
            "spdx/SATELLITE-6.15-RHEL-8.json", // 1.21
            "spdx/OCP-TOOLS-4.11-RHEL-8.json", // 1.24
            "spdx/quarkus-bom-3.2.11.Final-redhat-00001.json", // 1.26.0.redhat-00001
        ])
        .await?;

    let sat_id = Id::parse_uuid(ingest_results[1].id.clone())?;

    let sat_sbom = sbom_service
        .fetch_sbom_details(sat_id, vec![], &ctx.db)
        .await?;
    assert!(sat_sbom.is_some());

    let sat_sbom = sat_sbom.unwrap();
    assert_eq!(1, sat_sbom.advisories.len());

    let sat_status = &sat_sbom.advisories[0].status[0];

    // first, ensure our assumptions are correct and
    // the pURL is indeed part of the SBOM we think
    // it is.
    assert_eq!(sat_status.status, "affected");

    assert_eq!(1, sat_status.packages.len());

    assert_eq!(
        sat_status.packages[0].purl[0].head.purl.to_string(),
        "pkg:maven/org.apache.commons/commons-compress@1.21"
    );

    let quarkus_id = Id::parse_uuid(ingest_results[3].id.clone())?;

    let quarkus_sbom = sbom_service
        .fetch_sbom_details(quarkus_id, vec![], &ctx.db)
        .await?;

    assert!(quarkus_sbom.is_some());

    let quarkus_sbom = quarkus_sbom.unwrap();

    // Quarkus should /not/ be affected.
    assert!(quarkus_sbom.advisories.is_empty());

    let vuln = vuln_service
        .fetch_vulnerability("CVE-2024-26308", Default::default(), &ctx.db)
        .await?
        .unwrap();

    log::debug!("{vuln:#?}");

    // Collect and sort the SBOMs by their document_id for consistent iteration.
    let mut sboms: Vec<_> = vuln.advisories[0].sboms.iter().collect::<Vec<_>>();
    sboms.sort_by_key(|sbom| sbom.head.document_id.clone().expect("No document id"));

    // Define the expected PURL and version pairs.
    let expected = [
        (
            "https://access.redhat.com/security/data/sbom/spdx/OCP-TOOLS-4.11-RHEL-8",
            "pkg:maven/org.apache.commons/commons-compress",
            "1.24.0",
        ),
        (
            "https://access.redhat.com/security/data/sbom/spdx/SATELLITE-6.15-RHEL-8",
            "pkg:maven/org.apache.commons/commons-compress",
            "1.21",
        ),
    ];

    // Iterate through sorted SBOMs and validate each entry.
    for (sbom, (expected_id, expected_purl, expected_version)) in sboms.iter().zip(&expected) {
        assert_eq!(
            sbom.head.document_id.clone().expect("No document id"),
            *expected_id
        );

        // Get the affected PURL status for the SBOM.
        let purl = sbom.purl_statuses["affected"]
            .iter()
            .next()
            .expect("no purl status");
        assert_eq!(purl.head.purl.to_base().to_string(), *expected_purl);
        assert_eq!(purl.head.purl.version.as_deref(), Some(*expected_version));
    }

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn sbom_without_cpe_matching(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let sbom_service = SbomService::new(ctx.db.clone());

    let ingest_results = ctx
        .ingest_documents([
            // This CSAF file has CPEs
            "csaf/rhsa-2025_10698.json",
            // This Syft-generate SBOM has no CPE
            "cyclonedx/mtr-rhel8-operator_1.2.7.json",
        ])
        .await?;

    let mtr_id = Id::parse_uuid(ingest_results[1].id.clone())?;

    let mtr_sbom = sbom_service
        .fetch_sbom_details(mtr_id, vec![], &ctx.db)
        .await?;
    assert!(mtr_sbom.is_some());

    let mtr_sbom = mtr_sbom.unwrap();
    // The test checks the advisory (with CPE) correlates with the SBOM (with no CPE)
    assert_eq!(1, mtr_sbom.advisories.len());
    assert_eq!(3, mtr_sbom.advisories[0].status.len());

    let mtr_status = &mtr_sbom.advisories[0].status[0];

    assert_eq!(mtr_status.status, "affected");

    assert_eq!(2, mtr_status.packages.len());

    assert_eq!(
        mtr_status.packages[0].purl[0].head.purl.to_string(),
        "pkg:rpm/redhat/libxml2@2.9.7-18.el8_10.1?arch=x86_64&distro=rhel-8.10&upstream=libxml2-2.9.7-18.el8_10.1.src.rpm"
    );

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn sbom_with_multiple_cpes_not_breaking(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let sbom_service = SbomService::new(ctx.db.clone());

    let ingest_results = ctx
        .ingest_documents([
            // This SBOM has multiple CPEs and test checks this works with conditions from CONTEXT_CPE_FILTER_SQL
            "spdx/SATELLITE-6.15-RHEL-8.json", // 1.21
        ])
        .await?;

    let sat_id = Id::parse_uuid(ingest_results[0].id.clone())?;

    let sat_sbom = sbom_service
        .fetch_sbom_details(sat_id, vec![], &ctx.db)
        .await?;
    assert!(sat_sbom.is_some());

    let sat_sbom = sat_sbom.unwrap();
    assert_eq!(0, sat_sbom.advisories.len());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn product_statuses(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let vuln_service = VulnerabilityService::new();
    let sbom_service = SbomService::new(ctx.db.clone());
    let purl_service = PurlService::new();

    let ingest_results = ctx
        .ingest_documents([
            "csaf/cve-2023-0044.json",
            "quarkus/v2/quarkus-bom-2.13.8.Final-redhat-00004.json",
        ])
        .await?;

    let quarkus_id = Id::parse_uuid(&ingest_results[1].id)?;

    let quarkus_sbom = sbom_service
        .fetch_sbom_details(quarkus_id, vec![], &ctx.db)
        .await?;

    assert!(quarkus_sbom.is_some());

    let quarkus_sbom = quarkus_sbom.unwrap();

    log::debug!("{quarkus_sbom:#?}");

    assert!(!quarkus_sbom.advisories.is_empty());
    let quarkus_adv = &quarkus_sbom.advisories[0].status[0];

    assert_eq!(quarkus_adv.status, "affected");
    assert_eq!(quarkus_adv.vulnerability.identifier, "CVE-2023-0044");

    assert_eq!(quarkus_adv.packages.len(), 1);
    assert_eq!(quarkus_adv.packages[0].purl.len(), 1);
    assert_eq!(quarkus_adv.packages[0].purl[0].head.purl, Purl::from_str("pkg:maven/io.quarkus/quarkus-vertx-http@2.13.8.Final-redhat-00004?repository_url=https://maven.repository.redhat.com/ga/&type=jar").unwrap());

    let vuln = vuln_service
        .fetch_vulnerability("CVE-2023-0044", Default::default(), &ctx.db)
        .await?;

    assert!(vuln.is_some());

    let vuln = vuln.unwrap();

    log::debug!("{vuln:#?}");

    assert_eq!(1, vuln.advisories.len());

    let cve_advisory = vuln
        .advisories
        .iter()
        .find(|e| e.head.head.identifier == "https://www.redhat.com/#CVE-2023-0044");
    assert!(cve_advisory.is_some());
    let cve_advisory = cve_advisory.unwrap();

    log::debug!("{cve_advisory:#?}");

    assert_eq!(
        "pkg:maven/io.quarkus/quarkus-vertx-http",
        cve_advisory.sboms[0].purl_statuses["affected"]
            .clone()
            .into_iter()
            .next()
            .expect("no purl status")
            .head
            .purl
            .to_base()
            .to_string()
    );

    // Ensure that vuln->sbom mapping is good.
    let mut sboms: Vec<_> = vuln.advisories[0]
        .sboms
        .iter()
        .flat_map(|i| i.head.document_id.clone())
        .collect();
    sboms.sort();

    assert_eq!(
        sboms,
        ["https://access.redhat.com/security/data/sbom/spdx/quarkus-bom-2.13.8.Final-redhat-00004",],
    );

    // Ensure that purl->vuln mapping is good
    let purl = purl_service
        .purl_by_purl(
            &Purl::try_from("pkg:maven/io.quarkus/quarkus-vertx-http@2.13.8.Final-redhat-00004?repository_url=https://maven.repository.redhat.com/ga/&type=jar")?,
            Default::default(),
            &ctx.db,
        )
        .await?;

    log::debug!("{purl:#?}");
    assert!(purl.is_some());
    let purl = purl.unwrap();
    assert_eq!(1, purl.advisories.len());

    let cve_advisory = purl
        .advisories
        .iter()
        .find(|e| e.head.identifier == "https://www.redhat.com/#CVE-2023-0044");
    assert!(cve_advisory.is_some());

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn delete_vulnerability(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["cve/CVE-2024-29025.json"]).await?;

    let vuln = service
        .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
        .await?
        .expect("Vulnerability not found");

    assert_eq!(1, vuln.advisories.len());

    let id = &vuln.advisories[0].head.head.identifier;

    let affected = service.delete_vulnerability(id, &ctx.db).await?;
    assert_eq!(1, affected);

    assert!(
        service
            .fetch_vulnerability("CVE-2024-29025", Default::default(), &ctx.db)
            .await?
            .is_none()
    );

    let affected = service.delete_vulnerability(id, &ctx.db).await?;
    assert_eq!(0, affected);

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn vulnerability_queries(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "csaf/CVE-2023-20862.json",
        "cve/CVE-2023-20862.json",
        "cve/CVE-2023-42282.json",
        "csaf/RHBA-2024_1440.json",
        "cve/CVE-2023-39326.json",
        "csaf/rhsa-2023_5835.json",
        "cve/CVE-2023-39325.json",
        "cve/CVE-2023-44487.json",
        "cve/CVE-2024-7826.json",
        "cve/CVE-2017-20197.json",
        "cve/CVE-2025-1000.json",
    ])
    .await?;

    let vulns = service
        .fetch_vulnerabilities(q(""), Paginated::default(), Default::default(), &ctx.db)
        .await?;
    assert_eq!(8, vulns.items.len());
    let vulns = service
        .fetch_vulnerabilities(
            q("base_score>9"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-42282");
    let vulns = service
        .fetch_vulnerabilities(
            q("base_severity=critical"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-42282");
    let vulns = service
        .fetch_vulnerabilities(
            q("base_severity<high"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    tracing::debug!(test = "", "{vulns:#?}");
    assert_eq!(4, vulns.items.len());
    assert_eq!(
        *vulns.items[0].average_severity.as_ref().unwrap(),
        trustify_cvss::cvss3::severity::Severity::Medium
    );
    let vulns = service
        .fetch_vulnerabilities(
            q("base_severity>=high"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    tracing::debug!(test = "", "{vulns:#?}");
    assert_eq!(2, vulns.items.len());
    let vulns = service
        .fetch_vulnerabilities(
            q("20862"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].head.identifier, "CVE-2023-20862");

    let vulns = service
        .fetch_vulnerabilities(
            q("CVE-2024-7826"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].average_score, Some(6.2));
    assert_eq!(vulns.items[0].average_severity, Some(Severity::Medium));

    let vulns = service
        .fetch_vulnerabilities(
            q("CVE-2017-20197"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].average_score, Some(6.9));
    assert_eq!(vulns.items[0].average_severity, Some(Severity::Medium));

    let vulns = service
        .fetch_vulnerabilities(
            q("CVE-2023-39325"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(2, vulns.items[0].advisories.len());
    assert_eq!(vulns.items[0].advisories[0].score, Some(7.5));
    assert_eq!(vulns.items[0].advisories[0].severity, Some(Severity::High));
    assert_eq!(vulns.items[0].advisories[1].score, None);
    assert_eq!(vulns.items[0].advisories[1].severity, None);

    let vulns = service
        .fetch_vulnerabilities(
            q("CVE-2025-1000"),
            Paginated::default(),
            Default::default(),
            &ctx.db,
        )
        .await?;
    assert_eq!(1, vulns.items.len());
    assert_eq!(vulns.items[0].average_score, Some(5.3));
    assert_eq!(vulns.items[0].average_severity, Some(Severity::Medium));

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn analyze_purls(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "osv/RUSTSEC-2021-0079.json",
        "osv/GHSA-2ccf-ffrj-m4qw.json",
        "osv/GHSA-69ch-w2m2-3vjp.json",
        "osv/GHSA-ppp9-7jff-5vj2.json",
    ])
    .await?;

    // test empty request

    let result = service
        .analyze_purls_v3(Vec::<&str>::new(), &ctx.db)
        .await?;
    assert!(result.is_empty());

    // test some invalid PURLs

    for purl in ["this is not valid"].iter() {
        let result = service.analyze_purls_v3(vec![purl], &ctx.db).await;
        assert!(result.is_err());
    }

    // test some unsuitable PURLs

    for purl in ["pkg:npm/missing.version"].iter() {
        let result = service.analyze_purls_v3(vec![purl], &ctx.db).await;
        // must still be ok
        assert!(result.is_ok(), "{purl} should not fail the request");
        let result = result.unwrap();
        // has exactly one entry
        assert_eq!(result.len(), 1);
        // which is the purl
        let result = &result[*purl];
        // and has one warning, but no details
        assert_eq!(result.warnings.len(), 1);
        assert!(result.details.is_empty());
    }

    let expected = [
        "pkg:npm/%40fastify/passport@1.0.0",   // ECOSYSTEM:affected
        "pkg:cargo/hyper@0.14.9",              // SEMVER:affected - no namespace
        "pkg:golang/golang.org/x/text@v0.3.6", // GOLANG:affected
        "pkg:golang/golang.org/x/text@0.3.6",  // SEMVER:affected
    ];

    let not_found = [
        "pkg:npm/%40fastify/passport@2.3.0", // ECOSYSTEM:fixed
        "pkg:golang/github.com/metal3-io/baremetal-operator/apis@0.8.0", // Missing
        "pkg:cargo/hyper@0.14.11",           // SEMVER:fixed - no namespace
    ];

    let items: Vec<&str> = expected.iter().chain(&not_found).copied().collect();

    let result = service.analyze_purls_v3(items, &ctx.db).await?;

    expected.iter().for_each(|&item| {
        assert!(
            result.contains_key(item),
            "Expected key '{item}' not found in result"
        )
    });
    not_found.iter().for_each(|&item| {
        assert!(
            !result.contains_key(item),
            "Unexpected key '{item}' found in result"
        )
    });
    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
#[ignore = "Requires #1873"]
async fn analyze_purls_no_score(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    const PURL: &str = "pkg:cargo/hyper@0.14.9";

    let service = VulnerabilityService::new();

    ctx.ingest_documents(["osv/RUSTSEC-2022-0022.json"]).await?;

    let result = service.analyze_purls_v3([PURL], &ctx.db).await?;

    // ensure there is no warning
    assert!(result[PURL].warnings.is_empty());

    // ensure we get an entry

    assert_eq!(result.len(), 1);
    let advisory = &result[PURL].details[0];
    let status = &advisory
        .purl_statuses
        .iter()
        .find(|status| status.purl_status.status == "affected")
        .unwrap();

    // the scores must be empty

    assert_eq!(0.0, status.purl_status.average_score);

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn analyze_purls_v2(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents([
        "osv/RUSTSEC-2021-0079.json",
        "osv/GHSA-2ccf-ffrj-m4qw.json",
        "osv/GHSA-69ch-w2m2-3vjp.json",
        "osv/GHSA-ppp9-7jff-5vj2.json",
    ])
    .await?;

    // test empty request

    let result = service
        .analyze_purls_v2(Vec::<&str>::new(), &ctx.db)
        .await?;
    assert!(result.is_empty());

    // test some invalid PURLs

    for purl in ["this is not valid"].iter() {
        let result = service.analyze_purls_v2(vec![purl], &ctx.db).await;
        assert!(result.is_err());
    }

    // test some unsuitable PURLs

    for purl in ["pkg:npm/missing.version"].iter() {
        let result = service.analyze_purls_v2(vec![purl], &ctx.db).await;
        // must still be ok
        assert!(result.is_ok(), "{purl} should not fail the request");
        let result = result.unwrap();
        // has exactly one entry
        assert_eq!(result.len(), 1);
        // which is the purl
        let result = &result[*purl];
        // and has one warning, but no details
        assert_eq!(result.warnings.len(), 1);
        assert!(result.details.is_empty());
    }

    let expected = [
        "pkg:npm/%40fastify/passport@1.0.0",   // ECOSYSTEM:affected
        "pkg:cargo/hyper@0.14.9",              // SEMVER:affected - no namespace
        "pkg:golang/golang.org/x/text@v0.3.6", // GOLANG:affected
        "pkg:golang/golang.org/x/text@0.3.6",  // SEMVER:affected
    ];

    let not_found = [
        "pkg:npm/%40fastify/passport@2.3.0", // ECOSYSTEM:fixed
        "pkg:golang/github.com/metal3-io/baremetal-operator/apis@0.8.0", // Missing
        "pkg:cargo/hyper@0.14.11",           // SEMVER:fixed - no namespace
    ];

    let items: Vec<&str> = expected.iter().chain(&not_found).copied().collect();

    let result = service.analyze_purls_v2(items, &ctx.db).await?;

    expected.iter().for_each(|&item| {
        assert!(
            result.contains_key(item),
            "Expected key '{item}' not found in result"
        )
    });
    not_found.iter().for_each(|&item| {
        assert!(
            !result.contains_key(item),
            "Unexpected key '{item}' found in result"
        )
    });
    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn analyze_purls_remediations_synthetic(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["csaf/synthetic-affected-with-purl.json"])
        .await?;

    // Test that remediations are correctly associated with specific purl_statuses
    // The test data has:
    // - test-package@1.0.0: vendor_fix + workaround
    // - test-package@1.5.0: mitigation only
    // - another-package@1.0.0: no remediations

    let result = service
        .analyze_purls_v3(
            vec![
                "pkg:npm/test-package@1.0.0",
                "pkg:npm/test-package@1.5.0",
                "pkg:npm/another-package@1.0.0",
            ],
            &ctx.db,
        )
        .await?;

    assert_eq!(result.len(), 3);

    // Check test-package@1.0.0 has vendor_fix and workaround
    let analysis_1_0_0 = &result["pkg:npm/test-package@1.0.0"];
    assert!(
        !analysis_1_0_0.details.is_empty(),
        "Should have vulnerability details for 1.0.0"
    );
    let vuln_1_0_0 = &analysis_1_0_0.details[0];
    assert_eq!(vuln_1_0_0.head.identifier, "CVE-2024-99999");
    let status_1_0_0 = vuln_1_0_0
        .purl_statuses
        .first()
        .expect("Should have at least one status for 1.0.0");
    assert_eq!(
        status_1_0_0.remediations.len(),
        2,
        "1.0.0 should have exactly 2 remediations (vendor_fix + workaround)"
    );
    assert!(
        status_1_0_0
            .remediations
            .iter()
            .any(|r| r.category == RemediationCategory::VendorFix),
        "1.0.0 should have vendor_fix"
    );
    assert!(
        status_1_0_0
            .remediations
            .iter()
            .any(|r| r.category == RemediationCategory::Workaround),
        "1.0.0 should have workaround"
    );
    assert!(
        !status_1_0_0
            .remediations
            .iter()
            .any(|r| r.category == RemediationCategory::Mitigation),
        "1.0.0 should NOT have mitigation"
    );

    // Check test-package@1.5.0 has only mitigation
    let analysis_1_5_0 = &result["pkg:npm/test-package@1.5.0"];
    assert!(
        !analysis_1_5_0.details.is_empty(),
        "Should have vulnerability details for 1.5.0"
    );
    let vuln_1_5_0 = &analysis_1_5_0.details[0];
    assert_eq!(vuln_1_5_0.head.identifier, "CVE-2024-99999");
    let status_1_5_0 = vuln_1_5_0
        .purl_statuses
        .first()
        .expect("Should have at least one status for 1.5.0");
    assert_eq!(
        status_1_5_0.remediations.len(),
        1,
        "1.5.0 should have exactly 1 remediation (mitigation)"
    );
    assert!(
        status_1_5_0
            .remediations
            .iter()
            .any(|r| r.category == RemediationCategory::Mitigation),
        "1.5.0 should have mitigation"
    );
    assert!(
        !status_1_5_0
            .remediations
            .iter()
            .any(|r| r.category == RemediationCategory::VendorFix),
        "1.5.0 should NOT have vendor_fix"
    );

    // Check another-package@1.0.0 has no remediations
    let analysis_another = &result["pkg:npm/another-package@1.0.0"];
    assert!(
        !analysis_another.details.is_empty(),
        "Should have vulnerability details for another-package"
    );
    let vuln_another = &analysis_another.details[0];
    let status_another = vuln_another
        .purl_statuses
        .first()
        .expect("Should have at least one status for another-package");
    assert_eq!(
        status_another.remediations.len(),
        0,
        "another-package should have no remediations"
    );

    Ok(())
}

#[test_context(TrustifyContext)]
#[test(tokio::test)]
async fn analyze_purls_remediations(ctx: &TrustifyContext) -> Result<(), anyhow::Error> {
    let service = VulnerabilityService::new();

    ctx.ingest_documents(["csaf/cve-2023-33201.json"]).await?;

    let result = service
        .analyze_purls_v3(
            vec!["pkg:rpm/redhat/eap7-bouncycastle@1.76.0-4.redhat_00001.1.el8eap?arch=noarch"],
            &ctx.db,
        )
        .await?;

    assert_eq!(result.len(), 1);

    let analysis_result =
        &result["pkg:rpm/redhat/eap7-bouncycastle@1.76.0-4.redhat_00001.1.el8eap?arch=noarch"];
    assert_eq!(
        analysis_result.details.len(),
        1,
        "Should have vulnerability details for eap7-bouncycastle@1.76.0-4.redhat_00001.el8eap"
    );

    let details = analysis_result.details.first().unwrap();
    assert_eq!(details.purl_statuses.len(), 1, "Should have PURL statuses");

    let remediations = &details.purl_statuses.first().unwrap().remediations;
    assert_eq!(remediations.len(), 1, "Should have remediations");
    let remediation = remediations.first().unwrap();

    assert_eq!(remediation.category, RemediationCategory::VendorFix);
    // Technically correct according to our current implementation, but semantically wrong.
    // See https://github.com/guacsec/trustify/issues/2240 for more information.
    // TODO: Update this assert once #2240 is addressed.
    assert_eq!(
        remediation.url,
        Some("https://access.redhat.com/errata/RHSA-2023:5486".to_string())
    );

    Ok(())
}
